\chapter{Untersuchung des MVC-Patterns und verwandter Patterns}

In dieser Untersuchung werden drei wichtige Design Patterns analysiert: \ac{MVC}, \ac{MVP} und \ac{MVVM}. Diese Patterns wurden basierend auf der Untersuchung von Aihara et al. \cite{aihara2012mvc} ausgewählt, da diese häufig in der Praxis verwendet werden und unterschiedliche Ansätze zur Strukturierung von Software bieten. Die Bewertung erfolgt anhand der in \hyperref[chap:methodik]{Kapitel 2} beschriebenen vier Kriterien: Modularität, Kohäsion, Kopplung sowie Code Overhead, um die jeweiligen Vor- und Nachteile zu ermitteln.

\section{MVC (Model-View-Controller)}

Das \ac{MVC}-Pattern bietet klare Vorteile in der Modularität und Wiederverwendbarkeit, da es eine strikte Trennung zwischen 
Modell, View und Controller vorsieht. Diese Trennung ermöglicht 
es Entwicklern, die Benutzeroberfläche zu ändern, ohne dass 
Änderungen am zugrunde liegenden Datenmodell und der Anwendungslogik notwendig sind. Dadurch wird die Wartbarkeit des Systems erhöht. Dieser Vorteil zeigt sich besonders in großen Projekten, bei denen eine klare Strukturierung der Codebasis essenziell ist \cite{eudl63}, 
\cite{researchgate65}.

Die Kopplung des \ac{MVC}-Patterns zwischen Controller und View wird oft als Nachteil angesehen. Diese starke Abhängigkeit bedeutet, dass Änderungen bei einer der beiden Komponenten häufig zu Änderungen in der anderen führen. Dadurch wird die Flexibilität des Systems verringert und der Wartungsaufwand erhöht \cite{researchgate65}.

Ein weiterer Nachteil des \ac{MVC}-Patterns ist der durch die Trennung entstehende Code Overhead. Dieser zeigt sich vor allem in der erhöhten Komplexität der Kommunikation zwischen den drei 
Komponenten. Dies kann insbesondere bei komplexen Benutzeroberflächen zu Leistungseinbußen führen. Hinzukommend kann der Entwicklungsprozess von Systemen mit mehreren Benutzeroberflächen (Views) verlangsamt und komplexer werden \cite{eudl63}.

\section{MVP (Model-View-Presenter)}

Das \ac{MVP}-Pattern fördert eine klare Trennung zwischen den verschiedenen Komponenten einer Architektur. Der Presenter fungiert als Vermittler zwischen dem Model und der View. Dadurch wird eine hohe Modularität erreicht \cite{qureshi2024}. Diese Trennung ermöglicht es, dass verschiedene Views den gleichen Presenter nutzen können. Dies reduziert die Anzahl der benötigten Komponenten und erhöht die Wiederverwendbarkeit des Codes.

Die Kohäsion im \ac{MVP}-Pattern ist hoch, da jede Komponente spezifische Aufgaben hat. Das Model kümmert sich um die Daten, die View um die Darstellung und der Presenter um die Vermittlung und Steuerung der Logik zwischen beiden. Die Kopplung zwischen View und Presenter ist jedoch relativ eng, da der Presenter direkten Zugriff auf die View hat, um sie zu aktualisieren. Dies kann die Testbarkeit der einzelnen Komponenten beeinträchtigen \cite{aihara2012mvc}. Im Vergleich zu \ac{MVC} bietet \ac{MVP} eine bessere Kontrolle über die Interaktion zwischen den Komponenten, da der Presenter als alleiniger Vermittler fungiert und die View passiver ist. Dies reduziert die Komplexität der Kopplung und verbessert die Testbarkeit.

Ein Nachteil von \ac{MVP} ist der zusätzliche Code Overhead, der durch die Interaktion zwischen Presenter und View entsteht. Der Presenter verwaltet die Benutzerinteraktionen und aktualisiert die View. Dies kann zu einem höheren Aufwand in der Codebasis führen. Dennoch überwiegen die Vorteile in Bezug auf Testbarkeit und Wartbarkeit oft diesen zusätzlichen Aufwand \cite{qureshi2024}.

\section{MVVM (Model-View-ViewModel)}

Das \ac{MVVM} (Model-View-ViewModel) Architekturdesign zeichnet sich durch eine klare Trennung von View- und Geschäftslogik aus. \ac{MVVM} bietet eine hohe Modularität, da die View und die Geschäftslogik (Model) durch das ViewModel klar getrennt sind. Diese Trennung ermöglicht es Entwicklern, die Benutzeroberfläche unabhängig von der Geschäftslogik zu entwickeln und zu testen. Die Möglichkeit der automatischen Synchronisierung zwischen View und ViewModel führt zu einer besseren Wartbarkeit und erleichtert die Wiederverwendung von Komponenten \cite{arcos2018comparative}.

Die Kohäsion in \ac{MVVM} ist hoch, da jede Komponente (Model, View, ViewModel) klar definierte Verantwortlichkeiten hat. Das Model kapselt die Geschäftslogik und Daten, die View ist für die Darstellung und Benutzerinteraktion zuständig, und das ViewModel dient als Bindeglied zwischen den beiden. Diese klare Trennung der Verantwortlichkeiten führt zu einer besseren Strukturierung des Codes und erleichtert die Wartung und Erweiterung der Anwendung \cite{arcos2018comparative}.

Ein Nachteil von \ac{MVVM} ist die potenziell hohe Kopplung zwischen View und ViewModel. Obwohl das ViewModel die Geschäftslogik von der View trennt, kann die extensive Nutzung von Datenbindungen (Bindings) zu einer engen Kopplung führen. Diese enge Kopplung kann die Flexibilität und Testbarkeit der Anwendung beeinträchtigen, da Änderungen in der View auch Anpassungen im ViewModel erfordern können \cite{arcos2018comparative}.

\ac{MVVM} kann zu einem höheren Code Overhead führen, da zusätzliche Klassen und Bindungen erforderlich sind, um die Trennung von View und Geschäftslogik zu gewährleisten. Insbesondere die Implementierung und Verwaltung von Bindungen zwischen View und ViewModel kann komplex und zeitaufwendig sein. Zudem kann die extensive Nutzung von Observer-Synchronisation zu Leistungseinbußen führen, insbesondere bei großen und komplexen Anwendungen \cite{arcos2018comparative}.

\section{Vergleich der vorgestellten Design Patterns}
Die Modell-View-Architekturmuster MVC, MVP und MVVM sind alle Teil der Familie der 
MV*-Designmuster, die sich auf die Trennung von Anliegen konzentrieren \cite{aihara2012mvc}. Diese 
Muster sind entstanden, um die Integration von Benutzeroberflächen mit der Anwendungsdomäne zu 
verbessern, insbesondere als grafische Benutzeroberflächen in den 1980er Jahren populär wurden. 
MVC wurde 1988 dokumentiert und stellte die Grundlage für die Entwicklung weiterer Muster dar 
\cite{aihara2012mvc}.

Alle MV*-Muster bestehen aus drei Hauptkomponenten: Modell (M), View (V) und einer dritten, 
variablen Komponente, die beschreibt, wie M und V miteinander kommunizieren \cite{aihara2012mvc}. Im 
MVC-Muster übernimmt der Controller die Rolle der Verbindung zwischen dem Modell und der 
Ansicht, indem er Benutzereingaben verarbeitet und die Darstellung aktualisiert 
\cite{aihara2012mvc}. Im Gegensatz dazu trennt MVP die Logik weiter, indem der Presenter die 
Interaktion zwischen View und Model steuert, was zu einer höheren Modularität führt 
\cite{aihara2012mvc}. In MVVM wird diese Trennung weiter verfeinert, indem das ViewModel als 
Bindeglied zwischen der View und dem Modell fungiert und eine automatische Synchronisierung 
ermöglicht \cite{aihara2012mvc}.